//堆内存
//对象数据类型或函数数据类型在定义的时候首先都会开辟一个堆内存,
堆内存有一个引用大的地址,如果外面有变量等知道了这个地址,我们说这个内存被占用了,
就不能销毁了
//我们想要让堆内存释放/销毁,只需要把所有引用它的变量值赋值为null即可,如果当前堆内存
没有任何东西被占用了,那么浏览器就会在空闲的时候把他销毁...(垃圾回收)
//把没用的堆内存,栈内存,回收释放掉就OK了,把没有用的变量容器设置为null,手动优化
前端性能
var obj1={name:"张三"};//开辟了堆内存

var obj2 = obj1;
obj1对象通过地址指向xxxfff000
我们称obj1引用堆内存

obj1=null
obj2=null
null为空对象指针
高级程序设计第三版

//谷歌浏览器每隔一定时间,查找一次,如果没有被占用,就把它清除(数组筛查)
//内存泄漏(IE)

//火狐浏览器是计数器的方式,如果为0,就删除了


//栈内存(作用域)
//全局作用域
//只有当页面关闭的时候全局作用域才会销毁


//私有作用域(只有函数执行会产生私有的作用域)
//一般情况下,函数执行会形成一个新的私有的作用域,当私有作用域中的代码执行完成后,
我们当前作用域都会主动的进行释放和销毁
一般情况下,作用域就会销毁

//但是还是存在特殊的情况的:
//当前私有作用域中的部分内容被作用域以外的东西占用了,那么当前这个作用域就不能销毁了

//1.函数执行返回了一个引用数据类型的值,并且在函数外面被一个其他的东西接受了,这种情况下
形成的私有作用域一般不会被销毁

function fn(){
var num = 100;
return function(){

}
}
var f =fn();
//fn执行形成的这个私有作用域就不能再销毁了,因为fn里面的堆内存,在fn栈内存
以window作用域下赋值给了f，如果返回了数字,则会销毁内存

//2.在一个私有作用域中给DOM元素的事件绑定方法,一帮情况下我们的私有作用域都不
销毁


div>有本事点我啊</div>
var oDiv = document.getElementById("div1");//获取的是对象数据类型的
function(){
 oDiv.onclick = function () {

}
}();当前自执行的函数形成的这个私有作用域也不销毁
当前函数执行有了栈内存,又形成了一个堆内存,堆内存被所在栈内存以外的内存给占用了
3. 下述情况属于不立即销毁->fn返回的函数没有被其他东西占用,但是还需要执行一次呢
,所以不销毁,当返回的值执行完成后,浏览器会在空闲的时候把它销毁了
function fn(){
 var num =100;
 return function(){

}
}
fn()();首先返回fn,返回一个小函数对应的内存地址,然后紧接着然返回的小函数再执行


for(){代码块

}
if(){

}
switch(){


}
<


